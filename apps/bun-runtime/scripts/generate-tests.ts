#!/usr/bin/env bun

/**
 * Test generation script
 * Runs both Gemini analysis and combinatorial generation
 */

import { CombinatorialTestGenerator } from '../src/combinatorial-test-generator';
import { TestGapAnalyzer } from '../src/test-gap-analyzer';
import { writeFileSync, existsSync, mkdirSync } from 'fs';
import { join } from 'path';

async function main() {
  console.log('üöÄ Starting comprehensive test generation...\n');
  
  // Ensure output directory exists
  if (!existsSync('generated-tests')) {
    mkdirSync('generated-tests', { recursive: true });
  }
  
  try {
    // 1. Run combinatorial analysis
    console.log('üìä Phase 1: Combinatorial Analysis');
    console.log('================================');
    
    const combinatorial = new CombinatorialTestGenerator();
    const combinations = await combinatorial.generateTestCombinations();
    
    console.log(`‚úÖ Generated ${combinations.length} test combinations`);
    
    // Save combinatorial tests
    const combinatorialPath = join('generated-tests', 'combinatorial-tests.test.ts');
    await combinatorial.saveTests(combinations, combinatorialPath);
    
    // 2. Run Gemini analysis (if API key available)
    console.log('\nü§ñ Phase 2: AI Gap Analysis');
    console.log('============================');
    
    const gapAnalyzer = new TestGapAnalyzer();
    const gapAnalysis = await gapAnalyzer.analyzeTestGaps();
    
    console.log(`‚úÖ Found ${gapAnalysis.untestedCompositions.length} untested compositions`);
    console.log(`‚úÖ Coverage: ${gapAnalysis.coverageReport.coverage}%`);
    
    // Save gap analysis tests
    const gapTestPath = join('generated-tests', 'gap-analysis-tests.test.ts');
    await gapAnalyzer.generateTestFile(gapAnalysis, gapTestPath);
    
    // 3. Generate comprehensive report
    console.log('\nüìù Phase 3: Report Generation');
    console.log('==============================');
    
    const report = {
      generated: new Date().toISOString(),
      summary: {
        combinatorialTests: combinations.length,
        gapAnalysisTests: gapAnalysis.testSuggestions.length,
        totalCoverage: gapAnalysis.coverageReport.coverage,
        totalAPIs: gapAnalysis.coverageReport.totalAPIs,
        testedAPIs: gapAnalysis.coverageReport.testedAPIs
      },
      combinatorial: {
        byCategory: combinations.reduce((acc, combo) => {
          acc[combo.category] = (acc[combo.category] || 0) + 1;
          return acc;
        }, {} as Record<string, number>),
        byPriority: combinations.reduce((acc, combo) => {
          acc[combo.priority] = (acc[combo.priority] || 0) + 1;
          return acc;
        }, {} as Record<string, number>),
        highComplexity: combinations.filter(c => c.complexity >= 4).length
      },
      gapAnalysis: {
        untestedCompositions: gapAnalysis.untestedCompositions.map(comp => ({
          name: comp.name,
          complexity: comp.complexity,
          apis: comp.apis
        })),
        criticalGaps: gapAnalysis.coverageReport.gaps,
        recommendations: gapAnalysis.testSuggestions
          .filter(s => s.priority === 'high')
          .map(s => ({ name: s.testName, reason: s.reason }))
      }
    };
    
    const reportPath = join('generated-tests', 'test-generation-report.json');
    writeFileSync(reportPath, JSON.stringify(report, null, 2));
    
    // 4. Generate README for generated tests
    const readme = `# Generated Tests

This directory contains automatically generated tests based on API analysis.

## Files Generated

- \`combinatorial-tests.test.ts\` - Tests generated by combinatorial analysis of API surface
- \`gap-analysis-tests.test.ts\` - Tests suggested by AI analysis of coverage gaps
- \`test-generation-report.json\` - Detailed report of the generation process

## Generation Summary

**Generated on:** ${new Date().toISOString()}
**Total Tests:** ${combinations.length + gapAnalysis.testSuggestions.length}
**API Coverage:** ${gapAnalysis.coverageReport.coverage}%

### Combinatorial Tests (${combinations.length})
${Object.entries(report.combinatorial.byCategory)
  .map(([cat, count]) => `- ${cat}: ${count} tests`)
  .join('\n')}

### Gap Analysis Tests (${gapAnalysis.testSuggestions.length})
${gapAnalysis.testSuggestions
  .slice(0, 5)
  .map(s => `- ${s.testName} (${s.priority} priority)`)
  .join('\n')}

### Top Recommendations
${report.gapAnalysis.recommendations
  .slice(0, 3)
  .map(r => `- **${r.name}**: ${r.reason}`)
  .join('\n')}

## Running the Tests

\`\`\`bash
# Run all generated tests
bun test generated-tests/

# Run only combinatorial tests
bun test generated-tests/combinatorial-tests.test.ts

# Run only gap analysis tests
bun test generated-tests/gap-analysis-tests.test.ts
\`\`\`

## Updating Tests

Re-run the generator to update tests after API changes:

\`\`\`bash
bun scripts/generate-tests.ts
\`\`\`
`;
    
    writeFileSync(join('generated-tests', 'README.md'), readme);
    
    // 5. Summary
    console.log('\nüéâ Generation Complete!');
    console.log('=======================');
    console.log(`üìÅ Generated tests saved to: generated-tests/`);
    console.log(`üìä Total test cases: ${combinations.length + gapAnalysis.testSuggestions.length}`);
    console.log(`üéØ High priority tests: ${combinations.filter(c => c.priority === 'high').length + gapAnalysis.testSuggestions.filter(s => s.priority === 'high').length}`);
    console.log(`üìà API Coverage: ${gapAnalysis.coverageReport.coverage}%`);
    console.log(`üìù Report: ${reportPath}`);
    
    // Show top recommendations
    console.log('\nüî• Top Recommendations:');
    report.gapAnalysis.recommendations.slice(0, 3).forEach((rec, i) => {
      console.log(`${i + 1}. ${rec.name}`);
      console.log(`   ${rec.reason}`);
    });
    
  } catch (error) {
    console.error('‚ùå Test generation failed:', error);
    process.exit(1);
  }
}

if (import.meta.main) {
  main();
}